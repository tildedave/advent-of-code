(ns advent2020.day20
  (:require [utils :as utils]
            [clojure.math.combinatorics :as combo]))

(defn parse-label [str]
  (->> (re-matches #"^Tile (\d+):$" str)
       (second)
       (utils/parse-int)))

(defn tile-line-to-num [line]
  (->> (map-indexed vector line)
       (filter #(= (second %) \#))
       (map first)
       (map (partial bit-shift-left 1))
       (reduce +)))

(defn flip-tile-num [num]
  (loop [idx 0
         num num
         result 0]
    (if (= idx 10) result
        (recur
         (inc idx)
         (bit-shift-right num 1)
         (bit-or (bit-shift-left result 1) (if (bit-test num 0) 1 0))))))

;; this is the dihedral group of order 8
;; it's generated by a rotation (order 4) and a reflection (order 2)

(defn rotate-tile-right [{:keys [top bottom left right]}]
  {:right top
   :bottom (flip-tile-num right)
   :left bottom
   :top (flip-tile-num left)})

(defn flip-tile [{:keys [top bottom left right]}]
  {:right left
   :left right
   :top (flip-tile-num top)
   :bottom (flip-tile-num bottom)})

;; it's not clear how unique the edges are going to be.

(bit-shift-left 1 0)
(tile-line-to-num "#.#.#####.")

(defn parse-edges [lines]
  (update-vals
   {:top (first lines)
   :bottom (last lines)
   :left (map #(.charAt % 0) lines)
   :right (map #(.charAt % 9) lines)}
   tile-line-to-num))

(parse-label "Tile 3079:")

(defn tile-matches? [tile1 tile2]
  (cond (= (tile1 :bottom) (tile2 :top)) :bottom
        (= (tile1 :left) (tile2 :right)) :left
        (= (tile1 :top) (tile2 :bottom)) :top
        (= (tile1 :right) (tile2 :left)) :right
        :else nil))

(cons 1 [1 2 3])

;; for any two tiles, we fix one tile and rotate/flip the other, see if they
;; could be adjacent.
;; logic programming would probably be a pretty good way to solve this.
(defn possible-pairs [tiles]
  (->>
   (for [[tile1-id tile2-id] (combo/cartesian-product (keys tiles) (keys tiles))]
    (if (= tile1-id tile2-id) nil
        (let [tile1 (tiles tile1-id)]
          (loop [tile2 (tiles tile2-id)
                 transforms []
                 results []
                 n 0]
            (if (= n 4)
              [tile1-id tile2-id results]
              (let [m1 (tile-matches? tile1 tile2)
                    m2 (tile-matches? tile1 (flip-tile tile2))]
            ;; (println "tile1" tile1 "tile2" tile2 "m1" m1 "m2" m2)
                (recur (rotate-tile-right tile2)
                       (conj transforms 'rotate-right)
                       (cond-> results
                         m1 (conj {m1 transforms})
                         m2 (conj {m2 (conj transforms 'flip)}))
                       (inc n))))))))
   (remove nil?)
   (remove (fn [[_ _ l]] (empty? l)))
   (map (fn [[a n & rest]] {a {n rest}}))
   (reduce (fn [acc m] (merge-with merge acc m)))
   ))


(defn answer-part1 [filename]
  (->> (utils/read-input (format "2020/%s" filename))
       (utils/split-by "")
       (map (fn [[label & r]] {(parse-label label) (parse-edges r)}))
       (into {})
       (possible-pairs)
       (filter (fn [[n l]] (= (count l) 2)))
       (map first)
       (reduce *)))

(answer-part1 "day20-example.txt")
(answer-part1 "day20.txt")

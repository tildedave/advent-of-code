(ns advent2020.day20
   (:require [utils :as utils]
             [grid :as grid]
             [clojure.math.combinatorics :as combo]
             [clojure.math :as math]
             [clojure.set :as set]
             [clojure.string :as string]))

 (defn parse-label [str]
   (->> (re-matches #"^Tile (\d+):$" str)
        (second)
        (utils/parse-int)))

 (defn tile-line-to-num [line]
   (->> (map-indexed vector line)
        (filter #(= (second %) \#))
        (map first)
        (map (partial bit-shift-left 1))
        (reduce +)))

 (defn flip-tile-num [num]
   (loop [idx 0
          num num
          result 0]
     (if (= idx 10) result
         (recur
          (inc idx)
          (bit-shift-right num 1)
          (bit-or (bit-shift-left result 1) (if (bit-test num 0) 1 0))))))

;; this is the dihedral group of order 8
;; it's generated by a rotation (order 4) and a reflection (order 2)

(defn rotate-tile-right [{:keys [top bottom left right]}]
  (merge
   (if (nil? top) {} {:right top})
   (if (nil? right) {} {:bottom (flip-tile-num right)})
   (if (nil? bottom) {} {:left bottom})
   (if (nil? left) {} {:top (flip-tile-num left)})))

(defn flip-tile [{:keys [top bottom left right]}]
  (merge
   (if (nil? left) {} {:right left})
   (if (nil? right) {} {:left right})
   (if (nil? top) {} {:top (flip-tile-num top)})
   (if (nil? bottom) {} {:bottom (flip-tile-num bottom)})))

;; it's not clear how unique the edges are going to be.

(bit-shift-left 1 0)
(tile-line-to-num "#.#.#####.")

(defn parse-edges [lines]
  (update-vals
   {:top (first lines)
    :bottom (last lines)
    :left (map #(.charAt ^String % 0) lines)
    :right (map #(.charAt ^String % 9) lines)}
   tile-line-to-num))

(parse-label "Tile 3079:")

(defn tile-matches? [tile1 tile2]
  (cond (= (tile1 :bottom) (tile2 :top)) :bottom
        (= (tile1 :left) (tile2 :right)) :left
        (= (tile1 :top) (tile2 :bottom)) :top
        (= (tile1 :right) (tile2 :left)) :right
        :else nil))

;; for any two tiles, we fix one tile and rotate/flip the other, see if they
;; could be adjacent.
;; logic programming would probably be a pretty good way to solve this.
(defn tile-adjacencies [tiles]
  (->>
   (for [[tile1-id tile2-id] (combo/cartesian-product (keys tiles) (keys tiles))]
     (if (= tile1-id tile2-id) nil
         (let [tile1 (tiles tile1-id)]
           (loop [tile2 (tiles tile2-id)
                  transforms []
                  n 0]
             (if (= n 4)
               [tile1-id nil]
               (if-let [m1 (tile-matches? tile1 tile2)]
                 [tile1-id m1 tile2-id transforms]
                 (if-let [m2 (tile-matches? tile1 (flip-tile tile2))]
                   [tile1-id m2 tile2-id (conj transforms 'flip)]
                   (recur (rotate-tile-right tile2)
                          (conj transforms 'rotate-right)
                          (inc n)))))))))
   (remove nil?)
   (remove (fn [[_ l]] (nil? l)))
   (map (fn [[a n rest]] {a {n rest}}))
   (apply merge-with merge)))

(defn parse-tiles [filename]
  (->> (utils/read-input (format "2020/%s" filename))
       (utils/split-by "")
       (map (fn [[label & r]] {(parse-label label) (parse-edges r)}))
       (into {})))

(tile-adjacencies (parse-tiles "day20-example.txt"))

(defn parse-tiles-full [filename]
  (->> (utils/read-input (format "2020/%s" filename))
       (utils/split-by "")
       (map (fn [[label & r]] {(parse-label label) (mapv vec r)}))
       (into {})))

(defn answer-part1 [filename]
  (->> (parse-tiles filename)
       (tile-adjacencies)
       (filter (fn [[_ l]] (= (count (keys l)) 2)))
       (map first)
       (reduce *)))

(answer-part1 "day20-example.txt")
(answer-part1 "day20.txt")

;; so we need to actually assemble the image to make part 2 work.
;; we can assemble the image using DFS/BFS or whatever.  seems like we
;; don't have edges that don't match etc etc.
;; sea monster check seems straightforward once the full image is assembled.

(parse-tiles "day20-example.txt")

(int (math/sqrt 144))

;; what we need is an adjacency list of tiles along with the rotations to apply.
;; good news: we have already (tile-adjacencies).
;; bad news: we need to convert that into a grid.
;; the problem: we don't know where in the grid to place the tiles.
;; I suppose we could start with (say) the top right corner.  can we identify
;; the top right corner?  well, any corner could be the top right corner.  we
;; just pick a corner, rotate it so the connectors are right/bottom, then place
;; it. then we go from there.


(defn rotate-tile-full
   "Rotate a full tile to the right"
   [tile-full]
   (->> (grid/coords tile-full)
        (map (fn [[x y]] [[(- 9 y) x] (grid/at tile-full [x y])]))
        (reduce
         (fn [acc [[x y] ch]]
           (assoc-in acc [y x] ch))
         (->> (repeat 10 (repeat 10 0))
              (mapv vec)))))

(defn flip-tile-full
   "Flip a full tile around the middle, vertically"
   [tile-full]
   (->> (grid/coords tile-full)
        (map (fn [[x y]] [[(- 9 x) y] (grid/at tile-full [x y])]))
        (reduce
         (fn [acc [[x y] ch]]
           (assoc-in acc [y x] ch))
         (->> (repeat 10 (repeat 10 0))
              (mapv vec)))))

((parse-tiles-full "day20-example.txt") 2473)
((parse-tiles-full "day20-example.txt") 2473)
(rotate-tile-full ((parse-tiles-full "day20-example.txt") 2473))
(flip-tile-full ((parse-tiles-full "day20-example.txt") 2473))

;; OK seems right.

(defn rotate-adjacency [{:keys [top bottom left right]}]
  (merge
  (if (nil? top) {} {:right top})
  (if (nil? right) {} {:bottom right})
  (if (nil? bottom) {} {:left bottom})
  (if (nil? left) {} {:top left})))

(defn flip-adjacency [{:keys [top bottom left right]}]
  (merge
   (if (nil? top) {} (:top top))
   (if (nil? bottom) {} (:top bottom))
   (if (nil? left) {} {:right left})
   (if (nil? right) {} {:left right})
   ))


(defn transform-tile [tile transforms]
  (reduce
   (fn [tile transform]
     (condp = transform
       'rotate-right (rotate-tile-full tile)
       'flip (flip-tile-full tile)))
   tile
   transforms))

(defn transform-adjacency [adj transforms]
  (reduce
  (fn [adj transform]
    (condp = transform
      'rotate-right (rotate-adjacency adj)
      'flip (flip-adjacency adj)))
  adj
  transforms))

(defn neighbors [x y taken-spots grid-size]
  (->> (for [[dx dy] [[-1 0] [1 0] [0 -1] [0 1]]]
         [(+ x dx) (+ y dy)])
       (remove (partial contains? taken-spots))
       (filter (fn [[x y]] (and (< -1 x grid-size)
                                (< -1 y grid-size))))))

(defn starting-orientation [starting-tile]
  (loop [adj (second starting-tile)
         transforms []
         n 0]
    (if (= n 4) (throw (Exception. "could not determine starting orientation"))
        (if (and (:bottom adj) (:right adj))
          transforms
          (let [flipped-adj (flip-adjacency adj)]
            (if (and (:bottom flipped-adj) (:right flipped-adj))
              (conj transforms 'flip)
              (recur (rotate-adjacency adj)
                     (conj transforms 'rotate-right)
                     (inc n))))))))

(def test-image [[\. \# \# \. \. \. \. \# \# \# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\. \# \. \# \# \. \# \# \. \# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\. \# \# \. \# \# \# \. \. \# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\. \# \# \. \. \# \# \# \# \# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\. \. \. \. \. \# \. \. \# \. 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\# \. \# \# \. \. \# \. \. \. 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\# \# \# \# \. \# \# \# \# \. 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\. \. \# \# \# \# \# \. \. \# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\. \. \# \# \# \# \# \# \. \# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [\. \. \. \. \. \# \. \. \# \. 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
                 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]])

;; these do our bounds checking since the nil? removal leads to an empty
;; sequence.
(defn top-border [x y full-image]
  (->>
   (for [gx (range (* x 10) (* 10 (inc x)))]
     [gx (dec (* 10 y))])
   (map #(grid/at full-image %))
   (remove nil?)))

(defn bottom-border [x y full-image]
  (->>
   (for [gx (range (* x 10) (* 10 (inc x)))]
     [gx (* 10 (inc y))])
   (map #(grid/at full-image %))
   (remove nil?)))

(defn left-border [x y full-image]
  (->>
   (for [gy (range (* y 10) (* 10 (inc y)))]
     [(dec (* 10 x)) gy])
   (map #(grid/at full-image %))
   (remove nil?)))

(defn right-border [x y full-image]
  (->>
   (for [gy (range (* y 10) (* 10 (inc y)))]
     [(* 10 (inc x)) gy])
   (map #(grid/at full-image %))
   (remove nil?)))

(right-border 1 0 test-image)

(get-in test-image [9 0])

(grid/at test-image [9 0])

(use 'clojure.tools.trace)
(defn tile-compatible? [full-tile x y full-image]
  ;; a tile is compatible if its borders match, or if the border it is
  ;; matching is all 0s, or if the borders are OOB.
  ;; this has to happen for each border on the tile.
  ;; so, given a tile to put in a position, the borders are ....
  ;; top left corner of the tile is (* grid-size x) (* grid-size y)
  ;;
  ;; for each (valid) border, test that it matches.
  ;; sort of frustating.  need to also bound the things we check.
  ;; Reminder: I chose this direction because the previous direction
  ;; (rotation) seemed like it would be more difficult.  I can always
  ;; go back to that.
  (and
   (let [right (right-border x y full-image)
         tile-right (->> (for [y (range 0 10)] [9 y]) (map #(grid/at full-tile %)))]
    ;;  (println right tile-right)
     (or (empty? right)
         (= (first right) 0)
         (= right tile-right)))
   (let [left (left-border x y full-image)
         tile-left (->> (for [y (range 0 10)] [0 y]) (map #(grid/at full-tile %)))]
    ;;  (println left tile-left)
     (or (empty? left)
         (= (first left) 0)
         (= left tile-left)))
   (let [top (top-border x y full-image)
         tile-top (->> (for [x (range 0 10)] [x 0]) (map #(grid/at full-tile %)))]
    ;;  (println top tile-top)
     (or (empty? top)
         (= (first top) 0)
         (= top tile-top)))
   (let [bottom (bottom-border x y full-image)
         tile-bottom (->> (for [x (range 0 10)] [x 9]) (map #(grid/at full-tile %)))]
    ;;  (println bottom tile-bottom)
     (or (empty? bottom)
         (= (first bottom) 0)
         (= bottom tile-bottom)))
  ))


(defn transforms-to-place-tile [tile x y full-image]
  ;; try to place the tile at x, y in the grid (this is the reduced
  ;; x/y, e.g. example has bounds 3,3)
  ;; if we fail, flip and try again.
  ;; if we fail, rotate right and recurse.
  ;; eventually return nil.
  ;; (println "we want to place tile" tile x y)
  (loop
   [i 0
    tile tile
    transforms []]
    (if (= i 4) nil
        (if (tile-compatible? tile x y full-image)
          transforms
          (if (tile-compatible? (flip-tile-full tile) x y full-image)
            (conj transforms 'flip)
            (recur
             (inc i)
             (rotate-tile-full tile)
             (conj transforms 'rotate-right)))))))

(transforms-to-place-tile
 ((parse-tiles-full "day20-example.txt") 2473)
 0 1
 test-image)

(defn assemble-image [tiles-full tile-adjacencies]
  (let [grid-size (int (math/sqrt (count (keys tiles-full))))
        starting-tile (->> tile-adjacencies
                           (filter (fn [[_ l]] (= (count l) 2)))
                           (first))
        full-image (->> (repeat (* grid-size 10) (repeat (* grid-size 10) 0))
                        (mapv vec))]
    (loop [queue [[(first starting-tile) 0 0 (starting-orientation starting-tile)]]
           image full-image
           placed-tiles #{}
           taken-spots #{}
           n 0]
      (cond
        (empty? queue) image
        ;; (= n 3) image
        :else
        (let [[i x y transforms] (get queue 0)
              next-queue (subvec queue 1)
              tile-to-place (transform-tile (tiles-full i) transforms)
              next-image (->> tile-to-place
                              (grid/coords)
                              (map (fn [[tx ty]] [(+ tx (* x 10)) (+ ty (* y 10))
                                                  (grid/at tile-to-place [tx ty])]))
                              (reduce
                               (fn [acc [x y ch]]
                                 (assoc-in acc [y x] ch))
                               image))
              next-placed-tiles (conj placed-tiles i)
              next-taken-spots (conj taken-spots [x y])
              neighbor-coords (neighbors x y taken-spots grid-size)]
          ;; we are going to brute force the rotation.  the transforms involved
          ;; CAN be used but my head hurts.  we know the adjacency for each tiles,
          ;; we know for each tile, what neighbors are unoccupied, we fit the
          ;; adjacencies into the unoccupied neighbors, we are done.
          (recur
           (reduce
            conj
            next-queue
             (for [n (-> (tile-adjacencies i) (vals) (set) (set/difference next-taken-spots))]
              (->> neighbor-coords
                   (map (fn [[x y]]
                          [n x y (transforms-to-place-tile (tiles-full n) x y next-image)]))
                   (remove (fn [[_ _ _ l]] (nil? l)))
                   (first))))
           next-image
           next-placed-tiles
           next-taken-spots
           (inc n))
          )))))


(defn image-to-string [image]
  (string/join "\n" (map string/join image)))

(assemble-image (parse-tiles-full "day20-example.txt")
                (tile-adjacencies (parse-tiles "day20-example.txt")))


;; (tile-adjacencies (parse-tiles "day20-example.txt"))
  ;; fill out the full image.
  ;; I guess we start with a corner tile, follow.
 )


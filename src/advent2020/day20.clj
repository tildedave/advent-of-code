(ns advent2020.day20
  (:require [utils :as utils]
            [clojure.math.combinatorics :as combo]
            [clojure.math :as math]))

(defn parse-label [str]
  (->> (re-matches #"^Tile (\d+):$" str)
       (second)
       (utils/parse-int)))

(defn tile-line-to-num [line]
  (->> (map-indexed vector line)
       (filter #(= (second %) \#))
       (map first)
       (map (partial bit-shift-left 1))
       (reduce +)))

(defn flip-tile-num [num]
  (loop [idx 0
         num num
         result 0]
    (if (= idx 10) result
        (recur
         (inc idx)
         (bit-shift-right num 1)
         (bit-or (bit-shift-left result 1) (if (bit-test num 0) 1 0))))))

;; this is the dihedral group of order 8
;; it's generated by a rotation (order 4) and a reflection (order 2)

(defn rotate-tile-right [{:keys [top bottom left right]}]
  (merge
   (if (nil? top) {} {:right top})
   (if (nil? right) {} {:bottom (flip-tile-num right)})
   (if (nil? bottom) {} {:left bottom})
   (if (nil? left) {} {:top (flip-tile-num left)})))

(defn flip-tile [{:keys [top bottom left right]}]
  (merge
   (if (nil? left) {} {:right left})
   (if (nil? right) {} {:left right})
   (if (nil? top) {} {:top (flip-tile-num top)})
   (if (nil? bottom) {} {:bottom (flip-tile-num bottom)})))

;; it's not clear how unique the edges are going to be.

(bit-shift-left 1 0)
(tile-line-to-num "#.#.#####.")

(defn parse-edges [lines]
  (update-vals
   {:top (first lines)
   :bottom (last lines)
   :left (map #(.charAt ^String % 0) lines)
   :right (map #(.charAt ^String % 9) lines)}
   tile-line-to-num))

(parse-label "Tile 3079:")

(defn tile-matches? [tile1 tile2]
  (cond (= (tile1 :bottom) (tile2 :top)) :bottom
        (= (tile1 :left) (tile2 :right)) :left
        (= (tile1 :top) (tile2 :bottom)) :top
        (= (tile1 :right) (tile2 :left)) :right
        :else nil))

;; for any two tiles, we fix one tile and rotate/flip the other, see if they
;; could be adjacent.
;; logic programming would probably be a pretty good way to solve this.
(defn tile-adjacencies [tiles]
  (->>
   (for [[tile1-id tile2-id] (combo/cartesian-product (keys tiles) (keys tiles))]
    (if (= tile1-id tile2-id) nil
        (let [tile1 (tiles tile1-id)]
          (loop [tile2 (tiles tile2-id)
                 transforms []
                 n 0]
            (if (= n 4)
              [tile1-id tile2-id nil]
              (if-let [m1 (tile-matches? tile1 tile2)]
                [tile1-id tile2-id {m1 transforms}]
                (if-let [m2 (tile-matches? tile1 (flip-tile tile2))]
                  [tile1-id tile2-id {m2 (conj transforms 'flip)}]
                  (recur (rotate-tile-right tile2)
                       (conj transforms 'rotate-right)
                       (inc n)))))))))
   (remove nil?)
   (remove (fn [[_ _ l]] (nil? l)))
   (map (fn [[a n rest]] {a {n rest}}))
   (apply merge-with merge)
   ))

(tile-adjacencies (parse-tiles "day20-example.txt"))

(defn parse-tiles [filename]
  (->> (utils/read-input (format "2020/%s" filename))
       (utils/split-by "")
       (map (fn [[label & r]] {(parse-label label) (parse-edges r)}))
       (into {})))

(defn parse-tiles-full [filename]
  (->> (utils/read-input (format "2020/%s" filename))
       (utils/split-by "")
       (map (fn [[label & r]] {(parse-label label) r}))
       (into {})))

(defn answer-part1 [filename]
  (->> (parse-tiles filename)
       (tile-adjacencies)))
      ;;  (filter (fn [[_ l]] (= (count )(keys l) 2)))
      ;;  (map first)
      ;;  (reduce *)))

(answer-part1 "day20-example.txt")
(answer-part1 "day20.txt")

;; so we need to actually assemble the image to make part 2 work.
;; we can assemble the image using DFS/BFS or whatever.  seems like we
;; don't have edges that don't match etc etc.
;; sea monster check seems straightforward once the full image is assembled.

(parse-tiles "day20-example.txt")

(int (math/sqrt 144))

;; what we need is an adjacency list of tiles along with the rotations to apply.
;; good news: we have already (tile-adjacencies).
;; bad news: we need to convert that into a grid.
;; the problem: we don't know where in the grid to place the tiles.
;; I suppose we could start with (say) the top right corner.  can we identify
;; the top right corner?  well, any corner could be the top right corner.  we
;; just pick a corner, rotate it so the connectors are right/bottom, then place
;; it. then we go from there.

(defn assemble-image [tiles-full tile-adjacencies]
  (let [grid-size (int (math/sqrt (count (keys tiles-full))))
        starting-tile (->> tile-adjacencies
                           (filter (fn [[_ l]] (= (count l) 2)))
                           (first))]
    starting-tile))

(tile-adjacencies (parse-tiles "day20-example.txt"))

(assemble-image (parse-tiles-full "day20-example.txt")
                (tile-adjacencies (parse-tiles "day20-example.txt")))

  ;; fill out the full image.
  ;; I guess we start with a corner tile, follow.
  )


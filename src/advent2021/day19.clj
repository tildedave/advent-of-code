(ns advent2021.day19
  (:require [clojure.math.combinatorics :as combo]
            [advent2021.utils :as utils]))

;; so we need a bunch of rotation matrices.
;;     (1 0 0)
;; I = (0 1 0)
;;     (0 0 1)
;; essentially any rotation matrix that respects handedness
;; (e.g. does not flip) and has no real eigenvectors is
;; what we're looking for.
;; the space should be generated by 3 matrices and their inverses.
;; also rotating 3 in one direction is the same as rotating backwards,
;; that sort of thing.
;; so the general rotation (keeping z fixed) is
;;     (cos th -sin th 0)
;; R = (sin th cos th  0)
;;     (0      0       1)
;; except here theta is only pi / 2, pi, 2pi
;; and in fact we only need 1 rotation per axis as the others
;; are generated by it.
;; here are our rotation matrices:
;;   (0 -1 0)   (0 0 -1)    (1 0 0)
;; z (1 0 0)  y (0 1 0)   x (0 0 -1)
;;   (0 0 1)    (1 0 0)     (0 1 0)
;; then I think it is just I, -I.
;; OK, these 3 and their additive inverses generate the space of rotations.
;; so, then it is a matter of matching all the points.

(def rotation-x [[1 0 0] [0 0 -1] [0 1 0]])
(def rotation-y [[0 0 -1] [0 1 0] [1 0 0]])
(def rotation-z [[0 -1 0] [1 0 0] [0 0 1]])

(defn transform [rotation-matrix v]
  [(reduce + (map * (get rotation-matrix 0) v))
   (reduce + (map * (get rotation-matrix 1) v))
   (reduce + (map * (get rotation-matrix 2) v))])

(defn minus [rotation-matrix]
  (mapv #(mapv (partial -) %) rotation-matrix))

(defn transpose [[row1 row2 row3]]
  [(mapv #(get % 0) [row1 row2 row3])
   (mapv #(get % 1) [row1 row2 row3])
   (mapv #(get % 2) [row1 row2 row3])])

(defn mult [matrix1 matrix2]
  (let [[row1 row2 row3] (transpose matrix2)]
    [(transform matrix1 row1)
     (transform matrix1 row2)
     (transform matrix1 row3)]))

(mult rotation-x rotation-x)

(def all-rotations
  (->> [rotation-x rotation-y rotation-z]
       (mapcat #(vector % (mult % %) (mult (mult % %) %) (mult (mult % %) (mult % %))))
       (mapcat #(vector % (minus %)))))

;; so we also have the challenge of translations.

;; manhattan distance between the points is invariant after rotation.
;; I mean, any distance metric is invariant after rotation if it's a real
;; rotation :-)
;; mahattan distance should be invariant after translation too.
;; so the manhattan distance is the way to go.

(defn manhattan-distance [v1 v2]
  (->> (map - v1 v2)
       (map abs)
       (reduce +)))

(def pts-1
  [[-1,-1,1]
           [-2,-2,2]
           [-3,-3,3]
           [-2,-3,1]
           [5,6,-4]
           [8,0,7]])

(def pts-2  [
  [1,-1,1]
  [2,-2,2]
  [3,-3,3]
  [2,-1,3]
  [-5,4,-6]
  [-8,-7,0]
])


(->> (combo/combinations pts-1 2)
     (map #(apply manhattan-distance %)))


(->> (combo/combinations pts-2 2)
     (map #(apply manhattan-distance %)))


;; however, the manhattan distance does not solve everything by itself.
;; we also the challenge that only 12 points will overlap.
;; so manhattan distance between each set of points.
;; the example and the input both have 25-26 beacons each.
;; I think in practice this will be kind of obvious.

;; compute mahattan distance of each scanner (can be used for all detections)

(defn parse-point [line]
  (->> (.split line ",")
       (mapv utils/parse-int)))


(defn parse-report [lines]
  (->> lines
       (remove #(.contains % "scanner"))
       (partition-by (partial = ""))
       (remove (partial = (list "")))
       (map #(map parse-point %))
       (map-indexed vector)
       (into {})))

(parse-report (utils/read-input "day19-example.txt"))



(for [m (mapcat #(vector % (minus %)) [rotation-x rotation-y rotation-z])]
  m)

;; Guess for part 2: actually figuring out the size of the space.

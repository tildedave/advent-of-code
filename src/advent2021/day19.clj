(ns advent2021.day19
  (:require [clojure.math.combinatorics :as combo]
            [utils :as utils]
            [clojure.set :as set]
            [clojure.math :as math]))

;; so we need a bunch of rotation matrices.
;;     (1 0 0)
;; I = (0 1 0)
;;     (0 0 1)
;; essentially any rotation matrix that respects handedness
;; (e.g. does not flip) and has no real eigenvectors is
;; what we're looking for.
;; the space should be generated by 3 matrices and their inverses.
;; also rotating 3 in one direction is the same as rotating backwards,
;; that sort of thing.
;; so the general rotation (keeping z fixed) is
;;     (cos th -sin th 0)
;; R = (sin th cos th  0)
;;     (0      0       1)
;; except here theta is only pi / 2, pi, 2pi
;; and in fact we only need 1 rotation per axis as the others
;; are generated by it.
;; here are our rotation matrices:
;;   (0 -1 0)   (0 0 -1)    (1 0 0)
;; z (1 0 0)  y (0 1 0)   x (0 0 -1)
;;   (0 0 1)    (1 0 0)     (0 1 0)
;; then I think it is just I, -I.
;; OK, these 3 and their additive inverses generate the space of rotations.
;; so, then it is a matter of matching all the points.

(def rotation-x [[1 0 0] [0 0 -1] [0 1 0]])
(def rotation-y [[0 0 1] [0 1 0] [-1 0 0]])
(def rotation-z [[0 -1 0] [1 0 0] [0 0 1]])
(def identity-matrix [[1 0 0] [0 1 0] [0 0 1]])

(defn transform [rotation-matrix v]
  [(reduce + (map * (rotation-matrix 0) v))
   (reduce + (map * (rotation-matrix 1) v))
   (reduce + (map * (rotation-matrix 2) v))])

(defn matrix-minus [rotation-matrix]
  (mapv #(mapv (partial -) %) rotation-matrix))

(defn transpose [[row1 row2 row3]]
  [(mapv #(% 0) [row1 row2 row3])
   (mapv #(% 1) [row1 row2 row3])
   (mapv #(% 2) [row1 row2 row3])])

(defn matrix-mult [matrix1 matrix2]
  (let [[row1 row2 row3] (transpose matrix2)]
    (transpose
     [(transform matrix1 row1)
      (transform matrix1 row2)
      (transform matrix1 row3)])))

(matrix-mult [[12 8 4] [3 17 14] [9 8 10]] [[5 19 3] [6 15 9] [7 8 16]])

(matrix-mult rotation-x rotation-x)


(defn matrix-pow [matrix n]
  (loop [acc identity-matrix
         n n]
    (if (= n 0) acc
        (recur (matrix-mult matrix acc) (dec n)))))

(matrix-pow rotation-x 3)

;; https://stackoverflow.com/a/16453299/576087
(def all-rotations
  (->> (for [p (range 4)
             q (range 4)
             r (range 4)
             s (range 4)]
         (reduce matrix-mult
                 (list
                  (matrix-pow rotation-y p)
                  (matrix-pow rotation-x q)
                  (matrix-pow rotation-y r)
                  (matrix-pow rotation-x s))))
       (set)
       (seq)))

;; so we also have the challenge of translations.

;; manhattan distance between the points is invariant after rotation.
;; I mean, any distance metric is invariant after rotation if it's a real
;; rotation :-)
;; mahattan distance should be invariant after translation too.
;; so the manhattan distance is the way to go.

(defn manhattan-distance [v1 v2]
  (->> (map - v1 v2)
       (map abs)
       (reduce +)))

(defn euclidean-distance-squared [v1 v2]
  (->> (map - v1 v2)
       (map #(* % %))
       (reduce +)))

(def pts-1
  [[-1,-1,1]
   [-2,-2,2]
   [-3,-3,3]
   [-2,-3,1]
   [5,6,-4]
   [8,0,7]])

(def pts-2  [[1,-1,1]
             [2,-2,2]
             [3,-3,3]
             [2,-1,3]
             [-5,4,-6]
             [-8,-7,0]])

;; convert points into set
;; transform points (all matrices)
;; after transformation, we need to see if what translation is
(defn apply-translation [v1 v2]
  (mapv + v1 v2))

(defn vector-between [v1 v2]
  (mapv - v1 v2))

;; however, the distance does not solve everything by itself.
;; we also the challenge that only 12 points will overlap.
;; so distance between each set of points.
;; the example and the input both have 25-26 beacons each.
;; I think in practice this will be kind of obvious.

;; compute mahattan distance of each scanner (can be used for all detections)

(defn parse-point [line]
  (->> (.split line ",")
       (mapv utils/parse-int)))


(defn parse-report [lines]
  (->> lines
       (remove #(.contains % "scanner"))
       (partition-by (partial = ""))
       (remove (partial = (list "")))
       (map #(map parse-point %))
       (map-indexed vector)
       (into {})))

(def example-report (parse-report (utils/read-input "day19-example.txt")))
(def input-report (parse-report (utils/read-input "day19.txt")))

(->> (example-report 1)
     (#(combo/combinations % 2))
     (map #(vector % (apply euclidean-distance-squared %)))
     (into {}))

(defn distance-map [points]
  (->> points
       (#(combo/combinations % 2))
       (mapcat (fn [[p q]]
                 (let [dist (euclidean-distance-squared p q)]
                   (list {[p q] dist} {[q p] dist}))))
       (into {})))

(defn unchoose-2
  "n = (k 2) -> find k."
  [n]
  (let [ans (* n 2)]
    (loop [i 1]
      (let [test (* i (dec i))]
        (cond
          (= test ans) i
          (> test ans) -1
          :else (recur (inc i)))))))

(defn cross-product
  "compute the cross product of two vectors"
  [[a1 a2 a3] [b1 b2 b3]]
  [(- (* a2 b3) (* a3 b2))
   (- (* a3 b1) (* a1 b3))
   (- (* a1 b2) (* a2 b1))])

(defn normal-plane [p1 p2 p3]
  (cross-product (vector-between p2 p1) (vector-between p3 p1)))

(assert
 (= [3 9 1] (normal-plane [-1 1 2] [-4 2 2] [-2 1 5])))

(defn find-paired-points [d d1 d2 inv-d1 inv-d2]
  (let [[p1 p2] (inv-d1 d)
        [p1' p2'] (inv-d2 d)
              ;; we now need to find a point so that p1 -> p3 is in the common
              ;; distances.
              ;; the ordering is annoying.
        p3 (->> d1 (keys)
                (filter (fn [[p q]]
                          (or (and (= p1 p) (contains? inv-d2 (d1 [p1 q])))
                              (and (= p1 q) (contains? inv-d2 (d1 [p1 p]))))))
                (map (fn [[p q]] (if (= p1 p) q p)))
                (first))
              ;; we find p3, this is arbitrary.
              ;; these might not be the in the right order, however.
              ;; we need dist(p1,p2) = dist(p1',p2') etc.
              ;; so we will choose all permutations of these,
              ;; and take the ones that behave like we want.
        scanner2-plane-points (-> (d1 [p1 p3])
                                  (inv-d2)
                                  (conj p1' p2')
                                  (set)
                                  (combo/permutations))
        [p1' p2' p3'] (->>
                       (for [[p1' p2' p3'] scanner2-plane-points]
                         (if
                          (and (= (d2 [p1' p2']) (d1 [p1 p2]))
                               (= (d2 [p1' p3']) (d1 [p1 p3]))
                               (= (d2 [p2' p3']) (d1 [p2 p3])))
                           [p1' p2' p3']
                           nil))
                       (remove nil?)
                       (first))]
    (if p1' [[p1 p2 p3] [p1' p2' p3']] nil)))

;; we need 3 unique points from both to form a plane.
;; then we want to validate the other common points.
(defn find-rotation-and-translation [report scanner1 scanner2]
  (let [d1 (distance-map (report scanner1))
        d2 (distance-map (report scanner2))
        inv-d1 (set/map-invert d1)
        inv-d2 (set/map-invert d2)
        common-distances (set/intersection (set (keys inv-d1)) (set (keys inv-d2)))]
    ;; we only get out of bed if there is a 12 scanner overlap
    (if (< (count common-distances) 66)
      nil
      (let [
          ;; we need 3 points from n1 and 3 point that are the same from n2,
          ;; then we rotate one until we find the same normal vector,
          ;; then we figure out the translation from that.
          ;; not my comfort zone but it will be fun to see it work :-)
            [[p1 p2 p3] [p1' p2' p3']] (->> common-distances
                                            (map #(find-paired-points % d1 d2 inv-d1 inv-d2))
                                            (remove nil?)
                                            (first))
            n1 (normal-plane p1 p2 p3)
            n2 (normal-plane p1' p2' p3')
            rotation (->> all-rotations
                          (map #(vector % (transform % n2)))
                          (filter #(= (second %) n1))
                          (map first)
                          (first))
            translation (vector-between p1 (transform rotation p1'))]
        {:rotation rotation
         :translation translation}))))

(find-rotation-and-translation example-report 0 5)

(defn align-next-scanner [[report aligned unaligned scanner-locations]]
  (->> (for [aligned-scanner aligned
             unaligned-scanner unaligned]
         (let [result (find-rotation-and-translation report aligned-scanner unaligned-scanner)]
           (if (nil? result)
             nil
      ;; laziness ftw here I think
             (let [{:keys [rotation translation]} result
                   unaligned-points (report unaligned-scanner)
                   aligned-points (->> unaligned-points
                                       (map #(transform rotation %))
                                       (map #(apply-translation translation %)))]
               [(assoc report unaligned-scanner aligned-points)
                (conj aligned unaligned-scanner)
                (disj unaligned unaligned-scanner)
                (assoc scanner-locations unaligned translation)
                ]))))
       (remove nil?)
       (first)))

;; OK, so, we go through everything and align it
(defn align-scanners [parsed-report]
  (let [scanners (set (keys parsed-report))]
    (loop
     ;; arbitrarily align at 0 first.
     [[aligned-report aligned-scanners unaligned-scanners scanner-locations]
       [parsed-report #{(first scanners)} (disj scanners (first scanners)) {0 [0 0 0]}]]
      (if (empty? unaligned-scanners)
        [aligned-report scanner-locations]
        (recur
         (align-next-scanner
          [aligned-report aligned-scanners unaligned-scanners scanner-locations]))))))

(align-scanners example-report)

(defn answer-part1 [file]
  (->> (utils/read-input file)
       (parse-report)
       (align-scanners)
       (first)
       (vals)
       (apply concat)
       (set)
       (count)))

(answer-part1 "day19-example.txt")
(answer-part1 "day19.txt")

(defn answer-part2 [file]
  (->> (utils/read-input file)
       (parse-report)
       (align-scanners)
       (second)
       (vals)
       (#(combo/combinations % 2))
       (map #(apply manhattan-distance %))
       (sort >)
       (first)))

(answer-part2 "day19-example.txt")
(answer-part2 "day19.txt")

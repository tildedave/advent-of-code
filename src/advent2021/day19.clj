(ns advent2021.day19
  (:require [clojure.math.combinatorics :as combo]
            [advent2021.utils :as utils]
            [clojure.set :as set]
            [clojure.math :as math]))

;; so we need a bunch of rotation matrices.
;;     (1 0 0)
;; I = (0 1 0)
;;     (0 0 1)
;; essentially any rotation matrix that respects handedness
;; (e.g. does not flip) and has no real eigenvectors is
;; what we're looking for.
;; the space should be generated by 3 matrices and their inverses.
;; also rotating 3 in one direction is the same as rotating backwards,
;; that sort of thing.
;; so the general rotation (keeping z fixed) is
;;     (cos th -sin th 0)
;; R = (sin th cos th  0)
;;     (0      0       1)
;; except here theta is only pi / 2, pi, 2pi
;; and in fact we only need 1 rotation per axis as the others
;; are generated by it.
;; here are our rotation matrices:
;;   (0 -1 0)   (0 0 -1)    (1 0 0)
;; z (1 0 0)  y (0 1 0)   x (0 0 -1)
;;   (0 0 1)    (1 0 0)     (0 1 0)
;; then I think it is just I, -I.
;; OK, these 3 and their additive inverses generate the space of rotations.
;; so, then it is a matter of matching all the points.

(def rotation-x [[1 0 0] [0 0 -1] [0 1 0]])
(def rotation-y [[0 0 -1] [0 1 0] [1 0 0]])
(def rotation-z [[0 -1 0] [1 0 0] [0 0 1]])

(defn transform [rotation-matrix v]
  [(reduce + (map * (get rotation-matrix 0) v))
   (reduce + (map * (get rotation-matrix 1) v))
   (reduce + (map * (get rotation-matrix 2) v))])

(defn minus [rotation-matrix]
  (mapv #(mapv (partial -) %) rotation-matrix))

(defn transpose [[row1 row2 row3]]
  [(mapv #(get % 0) [row1 row2 row3])
   (mapv #(get % 1) [row1 row2 row3])
   (mapv #(get % 2) [row1 row2 row3])])

(defn mult [matrix1 matrix2]
  (let [[row1 row2 row3] (transpose matrix2)]
    [(transform matrix1 row1)
     (transform matrix1 row2)
     (transform matrix1 row3)]))

(mult rotation-x rotation-x)

(def all-rotations
  (->> [rotation-x rotation-y rotation-z]
       (mapcat #(vector % (mult % %) (mult (mult % %) %) (mult (mult % %) (mult % %))))
       (mapcat #(vector % (minus %)))))

;; so we also have the challenge of translations.

;; manhattan distance between the points is invariant after rotation.
;; I mean, any distance metric is invariant after rotation if it's a real
;; rotation :-)
;; mahattan distance should be invariant after translation too.
;; so the manhattan distance is the way to go.

(defn manhattan-distance [v1 v2]
  (->> (map - v1 v2)
       (map abs)
       (reduce +)))

(defn euclidean-distance-squared [v1 v2]
  (->> (map - v1 v2)
       (map #(* % %))
       (reduce +)
       (math/sqrt)))

(def pts-1
  [[-1,-1,1]
           [-2,-2,2]
           [-3,-3,3]
           [-2,-3,1]
           [5,6,-4]
           [8,0,7]])

(def pts-2  [
  [1,-1,1]
  [2,-2,2]
  [3,-3,3]
  [2,-1,3]
  [-5,4,-6]
  [-8,-7,0]
])


(->> (combo/combinations pts-1 2)
     (map #(apply manhattan-distance %)))


(->> (combo/combinations pts-2 2)
     (map #(apply manhattan-distance %)))


;; however, the manhattan distance does not solve everything by itself.
;; we also the challenge that only 12 points will overlap.
;; so manhattan distance between each set of points.
;; the example and the input both have 25-26 beacons each.
;; I think in practice this will be kind of obvious.

;; compute mahattan distance of each scanner (can be used for all detections)

(defn parse-point [line]
  (->> (.split line ",")
       (mapv utils/parse-int)))


(defn parse-report [lines]
  (->> lines
       (remove #(.contains % "scanner"))
       (partition-by (partial = ""))
       (remove (partial = (list "")))
       (map #(map parse-point %))
       (map-indexed vector)
       (into {})))

(def example-report (parse-report (utils/read-input "day19-example.txt")))

;; 12 choose 2 is 66 - so more than 66 is our combo.
;; inclusion-exclusion principle should carry us home without actually
;; mapping the beacons.
;; we can of course map the beacons too.

(defn unchoose-2
  "n = (k 2) -> find k."
  [n]
  (let [ans (* n 2)]
    (loop [i 1]
      (let [test (* i (dec i))]
        (cond
          (= test ans) i
          (> test ans) (throw (Exception. (format "could not find answer: %d" n)))
          :else (recur (inc i)))))))

(let [s1 (->> (combo/combinations (get example-report 0) 2)
              (map #(apply euclidean-distance-squared %))
              (set))
      s2 (->> (combo/combinations (get example-report 1) 2)
              (map #(apply euclidean-distance-squared %))
              (set))
      s3 (->> (combo/combinations (get example-report 2) 2)
              (map #(apply euclidean-distance-squared %))
              (set))
      s4 (->> (combo/combinations (get example-report 3) 2)
              (map #(apply euclidean-distance-squared %))
              (set))
      s5 (->> (combo/combinations (get example-report 4) 2)
              (map #(apply euclidean-distance-squared %))
              (set))]
  (count (set/intersection s2 s3)))

(defn answer-part1 [filename]
  ;; inclusion-exclusion, assuming distance is unique.
  ;; of course this is an assumption and might not be borne out by
  ;; the input.
  (let [report (parse-report (utils/read-input filename))
        num-beacons (count (keys report))
        distances
        (update-vals report
                     (fn [beacons]
                       (->> (combo/combinations beacons 2)
                            (map #(apply euclidean-distance-squared %))
                            (set))))]
    (loop [i 1
         total 0]
    (if (> i num-beacons) total
        ;; otherwise
        (let [func (case (mod i 2) 1 + 0 -)
              subtotal (->> (combo/combinations (vals distances) i)
                            (map #(reduce set/intersection %))
                            (map #(count %))
                            (map #(unchoose-2 %))
                            (reduce +))]
          (recur (inc i) (func total subtotal)))))))

(answer-part1 "day19-example.txt")
(answer-part1 "day19.txt")



(num-beacons example-report)

;;

;;  )


(->> (range 5)
     (map #(combo/combinations (example-report %) 2))
     (map (fn [l] (map #(apply euclidean-distance-squared %) l))))

( - (reduce + (map count (vals example-report)))
 12
 12)

(quot (* 12 11) 2)

;; even if we know that two scanners overlap, what's the next step?

(for [m (mapcat #(vector % (minus %)) [rotation-x rotation-y rotation-z])]
  m)

;; Guess for part 2: actually figuring out the size of the space.
